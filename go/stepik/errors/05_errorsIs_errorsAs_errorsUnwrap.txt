
/////////////////
//errors.Unwrap//
/////////////////
 - разворачивает ошибку и возвращает родительскую ошибку (ЕСЛИ ошибка реализует метод Unwrap)
 - parentErr := errors.Unwrap(err)


/////////////
//errors.Is//
/////////////
 - errors.Is можно считать эквивалентом "==" для всей цепочки ошибок
 - разворачивает всю цепочку ошибок и проверяет, нет ли среди звеньев цепочки искомой ошибки
 - для работы с ошибками-значениями (sentinel errors)
 - с ver1.13 теперь вместо
if fileLoadErr, ok := err.(FileLoadError); ok && fileLoadErr.Err == context.Canceled {}
 - мы можем писать
if errors.Is(err, context.Canceled) {}
 - или
switch {
case errors.Is(err, context.Canceled):
    // ...
case errors.Is(err, io.EOF):
    // ...
}

//Переопределение errors.Is
- внутри errors.Is(err, target) проверяется, реализует ли err свой собственный метод Is и вызывает его,
а если не реализует, то только тогда делает Unwrap
Поэтому метод Is можно легко переопределять для своих типов


/////////////
//errors.As//
/////////////
 - errors.As(err, target)
 - принимает два аргумента – ошибку err и указатель на место для хранения результата target
 - разворачивает цепочку ошибок, пока не встретит значение, которое можно положить в target (начиная с target)
 - чтобы получить значение ошибки в соответствии с её типом
 - если target указатель на интерфейс (необязательно error), то значение, хранящееся в err, должно реализовывать его
 - если target указатель на переменную иного типа, то ошибка ожидается такого же типа
 - для более сложных ошибок, содержащих дополнительную информацию
 - errors.As можно считать заменой проверок ошибок через type asserting
 - если нам не нужно работать с дополнительной информацией в сложной ошибке, а важно лишь знание о том, что произошла именно она
    - errors.As(err, new(net.UnknownNetworkError)): // Результат "улетит" во временную переменную
 - для переопределения поведения errors.As следует реализовать соответствующий интерфейс







