
////////////////////////////////
//Методы github.com/pkg/errors//
////////////////////////////////
//errors.New
 - так же, как и собрат из стандартной библиотеки, создает экземпляр ошибки
 - Отличается тем, что структура fundamental помимо сообщения несёт в себе стектрейс stack.
Вызываете функцию и она запишет в стектрейс место вызова.

//errors.Errorf
 - идентична своей сестрёнке из пакета fmt,
только помимо форматированного сообщения добавляет стектрейс к ошибке

//errors.WithStack
 - оборачивает переданную ошибку в *withStack, цепляя к ней стектрейс
 - А что делать, если стектрейс нам не нужен? Для этого пригодится следующая функция.

//errors.WithMessage, errors.WithMessagef
 - оборачивает переданную ошибку в *withMessage и цепляет к ней наше сообщение

//errors.Wrap
 - это комбинация двух методов выше, одновременно добавляет к ошибке и сообщение и стектрейс
 - На первый взгляд она кажется избыточной, но на удивление – это самая популярная функция модуля.
 - Будьте готовы к портянкам стеков, если вы бездумно Wrap'ите.
Лучший вариант использования github.com/pkg/errors,
это наличие Wrap/WithStack для самой глубокой ошибки и WithMessage(f) на уровнях выше.
Более того так мы уменьшаем оверхед от использования библиотеки, т.к. в целом WithMessagef быстрее fmt.Errorf.

//Типы *withMessage и *withStack
 - реализуют целую пачку интерфейсов среди которых error, fmt.Formatter, а также
помогает строить цепочки ошибок, а также красиво выводить их на экран.

//errors.Cause
 – это метод-прародитель errors.Unwrap из стандартной библиотеки:
 - Назначение метода ровно то же самое – получить оригинальную ошибку.
Только здесь оригинальной считается та ошибка, которая последняя реализует интерфейс causer
(Unwrap же разворачивает единожды, не в цикле)
 - Если в вашем проекте для работы с ошибками используется как стандартная библиотека, так и github.com/pkg/errors,
то для разворачивания ошибок лучше отказаться от errors.Cause в пользу errors.Is / errors.As
(неважно стандартных функций или из pkg/errors – мы помним, что они идентичны).

//errors.Unwrap
 - Эта функция ничем не примечательна, так как полностью идентична своему аналогу из стандартной библиотеки,
потому что именно он внутри и вызывается

//errors.Is, errors.As
 - Эти функции, как и Unwrap, были включены в стандартную библиотеку,
и после этого на неё же саму и были переписаны:

///////////////////////////////////////////////////
//Пример использования стандартного пакета errors//
///////////////////////////////////////////////////
func loadFiles(urls ...string) ([]File, error) {
    // ...
    if err != nil {
        return nil, &FileLoadError{url, err}
    }
    // ...
}

func transfer() error {
    _, err := loadFiles("www.golang-courses.ru")
    if err != nil {
        return fmt.Errorf("cannot load files: %w", err)
    }
    // ...
}

func handle() error {
    if err := transfer(); err != nil {
        return fmt.Errorf("cannot transfer files: %w", err)
    }
    // ...
}

func main() {
    var fileLoadErr *FileLoadError
    if err := handle(); errors.As(err, &fileLoadErr) {
        fmt.Println(fileLoadErr.URL) // www.golang-courses.ru
    }
}

//////////////////////////////////////////////
//Пример использования github.com/pkg/errors//
//////////////////////////////////////////////

func loadFiles(urls ...string) ([]File, error) {
    // ...
    if err != nil {
         // Прицепили стек в самом глубоком месте.
         return nil, errors.WithStack(&FileLoadError{url, err})
    }
    // ...
}

func transfer() error {
    _, err := loadFiles("www.golang-courses.ru")
    if err != nil {
        return errors.WithMessage(err, "cannot load files")
    }
    // ...
}

func handle() error {
    if err := transfer(); err != nil {
        return errors.WithMessage(err, "cannot transfer files")
    }
    // ...
    return nil
}

func main() {
    err := handle()
    fmt.Printf("%+v\n\n", err)

    if f, ok := errors.Cause(err).(*FileLoadError); ok { // Используем Cause!
        fmt.Println(f.URL) //ошибка со стек трейсом
    }
}

//////////////////////////////////////////
//Врапинг через pkg/errors VS fmt.Errorf//
//////////////////////////////////////////
//1. pkg/errors же всегда оборачивает ошибку слева
 - а с помощью fmt.Errorf можно поместить оборачиваемую ошибку в любое место новой ошибки

//2. Функции врапинга из pkg/errors врапят безусловно
 - нельзя заврапить ошибку так, чтобы для неё перестал работать errors.Is

//3. директива %w поддерживается только fmt.Errorf
 - pkg/errors использует fmt.Sprintf

//4. Враппинг nil ошибки
 - errors.Wrap без труда "проглатывает" её и остаётся nil
 - а вот с fmt.Errorf такое уже не прокатит
 - Такая особенность Wrap-функций github.com/pkg/errors позволяет не писать лишний раз if err != nil
если возврат ошибки происходит непосредственно перед return
