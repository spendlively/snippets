/////////
//errno//
/////////
 - глобальная переменная, в кот вызываемая функция стандартной библиотеки или системный вызов записывает код ошибки
 - по умолчанию = 0

//Стандартные ошибки:
 - EDOM – (Error domain) ошибка области определения.
 - EILSEQ – (Error invalid sequence) ошибочная последовательность байтов.
 - ERANGE – (Error range) результат слишком велик.
 - https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/errno-base.h
 - https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html

/////////////////////
//strerror & perror//
/////////////////////

//strerror
 - функция, возвращает строку с ошибкой по ее errno
 - strerror(errno)
 - может в процессе своей работы выставить в errno код EINVAL или ERANGE

//perror
 - функция, печатает описание текущего значения errno,
добавляя его к пользовательскому сообщению через пробел и двоеточие
 - perror("cannot open file"); // cannot open file: No such file or directory


//Проблемы использования errno
 - использование глобальной переменной - она может быть перетерта
 - in-band error indicator - использование одного "канала" и для передачи значения и для передачи информации,
    т.к. функции в си возвращают или:
    - валидное значение (не NULL указатель, положительное целое число, ноль, свой тип и пр.);
    - значение - индикатор ошибки (NULL указатель, отрицательное целое число, не ноль, свой тип и пр.)


///////////
//errno_t//
///////////
 - тип для хранения значений (кодов ошибок), которые может принимать переменная errno
 - errno_t fopen_s(FILE *streamptr, const char *filename, const char *mode);
 - пример errno_t: typedef int errno_t;

//Проблемы использования errno_t:
 - данный тип может быть не реализован компиляторами в принципе или реализован, но закрыт define'ом:
    #ifndef __STDC_LIB_EXT1__
        typedef int errno_t;
    #endif
 - хранить в нём можно только ошибки из известного списка (ISO, POSIX)
 - теряем поддержку perror (если в errno ничего не пишем) и strerror ("Unknown error" вместо нормального описания);
 - разработчику нужно знать существующие коды errno, чтобы своей ошибкой не перетереть системную,
соответственно, нужен удобный способ объединять множества своих ошибок и системных


//errno_t подойдёт для
 - обёрток над функциями стандартной библиотеки,
системными функциями и другим непользовательским кодом, уже использующим errno


//Итоги
 - отсутствие единого подхода к работе с ошибками в стандартной библиотеке и прикладном коде;
 - отсутствие широкоиспользуемого типа (аналога errno_t), показывающего, что функция возвращает ошибку;
 - отсутствие удобного способа получить человекочитаемое описание любой ошибки;
 - отсутствие удобного способа обогатить ошибку дополнительной информацией;
 - отсутствие удобного способа "завернуть" в свою ошибку "чужую";
 - проблема освобождения ресурсов при возврате ошибок – вынужденный переход к goto или копипаста;
 - отсутствие возможности возвращать из функции сразу и результат и индикатор ошибки (как следствие, ещё большее увеличение количества кода).
