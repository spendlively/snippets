
//Links
https://github.com/golang/go/wiki/LearnConcurrency


//Просмотр количества запущенных горутин
fmt.Printf("%d", runtime.NumGoroutine())


//При выходе из главной горутины все остальные горутины завершаются
go fmt.Println("Hello, World!")
//не выведет ничего


//Каналы
 - обеспечивают синхронизацию
 - работают по принципу очереди (FIFO)
 - работают со значениями определенного типа
 - под капотом указатель (при передаче канала в функцию не надо передавать указатель)
 - нулевое значение nil
 - НЕТ оператора стрелочка вправо "->"
 - есть только оператор стрелочка влево "<-"
 - отправка в канал происходит до завершения соответствующего чтения из канала



//Виды каналов
 - однонаправленные и двунаправленные
 - буферизированные и небуферизированные
 - открытые и закрытые (состояние)


//Операции с каналами
//1. Создание
ch = make(chan int) //небуферизованный
ch = make(chan int, 0) //небуферизованный
ch = make(chan int, 3) //буферизованный

//2. Отправление
ch <- x // в канал
x = <-ch // из канала
x, isOpened := <-ch // из канала

//3. Закрытие
close(ch)



//Небуферизованные каналы
 - отправление блокируется до тех пор, пока не будет выполнено получение
 - получение блокируется до тех пор, пока не будет выполнено отправление
 - 1 и 2 позволяют получить полную синхронизацию

//Синхронизация с небуферизованным каналом
var ch = make(chan struct{})

go func() {
    fmt.Println("Hello")
    ch <- struct{}{} //доч. горутина ждет, когда главная горутина начнет читать из канала, чтобы начать запись
}()

<-ch //гл. горутина ждет, когда доч. горутина начнет запись в канал, чтобы начать запись



//ВАЖНО
//Закрытые каналы
 - чтение из закрытого канала вернет нулевое значение
 - запись в закрытый канал вызовет панику
 - следовательно закрывать канал должен тот, кто в него пишет
 - но если писателей несколько, канал должна закрыть горутина, которая создала канал



//Синхронизация с небуферизованным каналом с помощью закрытия
var ch = make(chan struct{})

go func() {
    fmt.Println("Hello")
    close(ch)
}()

x, ok := <-ch
fmt.Println(x, ok)



//Однонаправленные каналы
//Зачем
 - читабельность кода
 - минимизирует ошибки (проверка на этапе компиляции)
//1. Функция с каналом только для записи
f(out chan<- int)
//2. Функция с каналом только для чтения
f(in <-chan int)
 - при записи в канал только для чтения будет ошибка компиляции



//Пишущая и читающая горутина
func fin(in <-chan int) {
	fmt.Println(<-in)
}

func fout(out chan<- int) {
	out <- 5
}

func main() {
	var ch = make(chan int)
	go fin(ch)
	go fout(ch)
	time.Sleep(5 * time.Second)
}



//Буферизованные каналы
 - make (chan int, 1)
 - запись в БК блокируется (на запись) только когда он заполнен
 - чтение из БК блокируется (на чтение) только когда он пуст
 - просмотр емкости канала
cap(ch)
 - просмотр количества элементов в канале
len(ch) //нельхя полагаться, т.к. значение сразу же устареет
 - если канал закрыт, но в канале остались несчитанные значения,
из него можно считать даже после закрытия



//ВАЖНО: ЧТЕНИЕ ИЗ ЗАКРЫТОГО БУФФЕРИЗИРОВАННОГО КАНАЛА
//1. Можно создать канал, добавить n значений и закрыть,
после чего считать n значений и флаг (value, true),
при след. считывания считается (zero_value, false):
ch := make(chan int, 2)
ch <- 1
ch <- 2
close(ch)
val, ok := <-ch // (1 true)
val, ok = <-ch // (2 true)
val, ok = <-ch // (0 false)

//2. Если канал не закрыть, при чтении из пустого канала будет deadlock
ch := make(chan int, 2)
ch <- 1
ch <- 2
val, ok := <-ch // (1 true)
val, ok = <-ch // (2 true)
val, ok = <-ch // fatal error: all goroutines are asleep - deadlock!



//Чтение из канала пока он не закрыт
//1.
var ch = make(chan int, 10)
for {
    x, ok := <-ch
    fmt.Println(x)
    if !ok {
        break
    }
}

//2.
var ch = make(chan int, 10)
for x := range ch {
    fmt.Println(x)
}
//пока канал не закрыт мы из range не выйдем



//Мультиплексирование select
 - select ждет пока один из каналов не будет готов на чтение или запись
 - если никто не готов, сработает default (если он объявлен)
 - обычно используется с циклом for
 - select{} (без параметров) будет ждать вечно



//Варианты работы с каналами
//1. Послать сигнал всем горутинам,
только после того, как будут созданы все
var start = make(chan struct{})

for i := 0; i < 100; i++ {
    go func() {
        <-start
    }()
}

close(start)



//Таймеры и тикеры
//Сигналы (Gracefull shutdown)
//Замыкания



//Когда использовать
//1. Когда использовать небуферизованные каналы
 - просто получить сигнал
 - синхронизировать 2 горутины
 - создание канала, чтобы при закрытии всем отправить сигнал
//2. Когда использовать буферизованные каналы
 - когда нужно передавать данные
//3. Как выбрать буфер

