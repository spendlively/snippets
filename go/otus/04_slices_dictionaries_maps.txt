
////////////////////////
/////////Массивы////////
////////////////////////

Массив
 - операция индексирования за пределом массива вызовет panic

var arr [256]int
var arr [10][10]string
//автоопределение размера
var arr [...]{1, 2, 3}
var arr [10]int{1, 2, 3}

//Операции
arr[3] = 1
len(arr)
//cap() нет
//получение слайсв
arr[3:5]

//Все значения массивов всегда заполнены



////////////////////////
/////////Слайсы/////////
////////////////////////
Слайсы
 - вектор
 - структура с переменной длиной
 - операция индексирования за пределом слайса вызовет panic
 - слайс всегда растет с конца (append)
 - zero value = nil

//неинициализированный слайс nil
var s []int

//с помощью литерала
s := []int{}

//с помощью make, s == {0, 0, 0}
//размер 3, емкость 3
s := make([]int, 3)
//размер 3, емкость 10
s := make([]int, 3, 10)

//Нельзя создать слайс с помощью new



//Добавление элементов в слайс
s[i] = 1

//panic
s[len(s) + 10] = 1

//добавление в конец слайса
s = append(s, 1)
s = append(s, 1, 2, 3)
s = append(s, s2...)

//append умеет работать с nil слайсами
var s [int]
s = append(s, 1)

//С помощью append можно добавить
//как 1 значение так и целый слайс
s.append(s, s2...)



//Особенность копирования слайсов с помощью :=
При копировании слайса скопируется только дескриптор,
и обе переменные будут ссылаться на одну область памяти.
Если после копирование добавлять данные в один слайс,
они добавятся у обоих слайсов, однако, как только
размер достигнет емкости, произойдет реаллокация
и с этого момента переменные будут указывать на разные
области памяти

//Клонирование слайса
s := []int{1,2,3}
s2 := make([]int,len(s))
copy(s2, s)

//Правила работы со стайсами
 - при передаче слайса в функцию копируется структурка (быстро),
сама память при этом не копируется
 - если нужно передать в функцию слайс чтобы его изменить,
функция должна вернуть новый слайс
 - менять переданный слайс безопасно только если вы его не увеличиваете



//Сортировка слайсов
import sort

s := []int{1,2,3}
sort.Ints(s)

s := []string{"1","2","3"}
sort.Stings(s)

//Функц стиль
s := []User{
    {'vasya', 18},
    {'petya', 19},
}
sort.Slice(s, func(i, j int) bool {
    return s[i].Age < s[j].Age
})

//Также можно реализовать sort.Interface



////////////////////////
//////Словари (Map)/////
////////////////////////
 - hash-таблица, dict (python), HashMap (java)
var m map[key_type]value_type
 - zero value = nil
 - ключ может быть любого типа,
для которого имеет смысл операция сравнения ==:
строки, числа, bool, каналы, интерфейсы, указатели, структуры
 - структуры можно сравнивать если в них нет слайсов
 - нельзя получить адрес элемента словаря,- ошибка на стадии компиляции
&m["key"]
 - ВАЖНО: нельзя писать в словарь параллельно из разных горутин

//Создание неинициализированного словаря (nil)
var m map[string]string //nil

//Создание инициализированного пустого словаря
m := map[string]string{} //len(m) = 0
//или
m := make(map[string]string) //len(m) = 0

//Создание с инициализацией
m := map[string]string{
    "one": "1",
    "two": "2",
    "three": "3",
}

//Создание с выделением памяти
m := make(map[string]string, 100)
//емкость не обязательна, т.к. словарь растет автоматически

//Получение значения по ключу
 - если значение по ключу не найдено, вернется Zero-value,
в отличае от слайса
 - чтение из неинициализированного словаря тоже работает

//Запись в словарь
 - при попытке записать в неинициализированный словарь произойдет паника
 - m[key] = value
 - записать в неинициализированный map пожно с помощью append

//Проверить наличие значения по ключу
value, ok = map[key]
_, ok = map[key]

//Удалить значение (работает всегда)
delete(m, key)



//Итерация по словарю (порядок не определен)
m := make(map[string]string)
for key, value := range m {}
for key, _ := range m {}
for _, value := range m {}

//Получение списка ключей или значений
 - таких функций в go нету, нужно писать самостоятельно
 - возможно потому что нет дженериков
//values []string
//или
values := make([]string, 0, len(m))
for _, value := range m {
    values = append(values, value)
}



//Лайфхак для группировки карт
//поскольку map возвращает zero value по не найденному ключу,
//zero value для слайса = nil
//и append умеет работать с nil
//можно коротко сгруппировать карту структур User по user.Host
hostUsers := map[string][]string{}
for _, user := range users {
    hostUsers[user.Host] = append(hostUsers[user.Host], user.Name)
}



//Карты и конкурентный доступ
 - Карты небезопасны для конкурентного доступа из разных горутин
 - доступ необходимо защитить с помощью sync.Mutex или sync.RWMutex

//sync.Mutex
var mutex sync.Mutex
mutex.Lock()
mutex.Unlock()

//sync.RWMutex
var mutex sync.RWMutex
mutex.Lock()
mutex.Unlock()
mutex.RLock()
mutex.RUnlock()

//Пример
var shared map[string]string
var mutex sync.RWMutex

func Get(key string) string {
    var s string
    mutex.RLock()
    s = shared[key]
    mutex.RUnlock()
    return s
}

func Set(key string, val string) {
    mutex.Lock()
    shared[key] = val
    mutex.Unlock()
}

//можно освобождать mutex с помощью defer
