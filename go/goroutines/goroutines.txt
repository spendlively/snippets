
//Горутина (goroutine)
 - корутины со всеми плюшками совместной многозадачности
 - планровщик go может раскидываьт их по разным потокам
 - планировщик маппит M горутин на N потоков (M:N схема)
 - 1 горутина не значит 1 поток (у меня в "helloworld" сразу появляется 5)
 - 100 горутин не значит 100 потоков (фактически получается на порядок меньше)
 - потоки очень легкие ок. 4кб за счет маленького стека 2кб и др оптимизаций
 - потоки можно параллелить чуть ли не миллионами



//Горутина (goroutine)
 - функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве
 - горутины очень легковесны, практически все расходы - это создание стека, который очень невелик
 - похожи на потоки, но они управляются самим Go, а не операционной системой
 - в процессе работы планировщик Go переключается между несколькими горутинами
в пределах одного потока операционной системы



//Память
 - в среднем можно рассчитывать примерно на 4,5kb на горутину
 - имея 4Gb оперативной памяти, можно содержать около 800 тысяч работающих горутин



//Применение горутин
1. Если нужна асинхронность. (работа с сетью, диском, базой данных, защищенным мьютексом ресурсом)
2. Если время выполнения функции достаточно велико и можно получить выигрыш, нагрузив другие ядра



//Анонимная горутина
go func() {
    fmt.Println("I'm running in my own go routine")
}()



//main
 - фунция main работает в собственной горутине
 - после завершения фунции main остальные горутины так же завершаются



//вызов таймера в конце main
- создает канал и посылает в него данные спустя 5 секунд
<-time.After(time.Second * 5)
- горутина заблокируется при чтении из канала, пока в него что-нибудь не пошлют,
тем самым давая другим горутиам 5 секунд времени на работу



//блокировка main
//чтобы горутина main не завершилась
1. создается специальный канал
2. основная горутина блокируется на чтении из него
3. как только дочерняя горутина завершает свою работу,
она делает запись в этот канал
4. основная горутина разблокируется и программа завершается

func main() {
  doneChan := make(chan string)
  go func() {
    // Сделать что-нибудь полезное
    doneChan <- “I’m all done!”
  }()

  <-doneChan // чтение блокируется до сигнала о завершении работы
}



//Чтение из канала в цикле for-range
 - если заранее не известно сколько, данных может быть в канале
go func() {
  for data := range yourChan {
    fmt.Println(data)
  }
}()
 - после того, как все данные из канала обработаны, цикл заблокируется на чтении
 - чтобы избежать блокировки, нужно закрыть канал вызовом close(channel)



//Неблокирующе чтение из канала
 - горутина прочитает из канала данные, если только они там есть
 - в противном случае выполняется блок default

myChan := make(chan string)

go func(){
 myChan <- “Message!”
}()

select {
 case msg := <- myChan:
  fmt.Println(msg)
 default:
  fmt.Println(“No Msg”)
}
<-time.After(time.Second * 1)
select {
 case msg := <- myChan:
  fmt.Println(msg)
 default:
  fmt.Println(“No Msg”)
}



//Неблокирующая запись в канал
select {
 case myChan <- “message”:
  fmt.Println(“sent the message”)
 default:
  fmt.Println(“no message sent”)
}


//Маленький стек
- В го есть механизм позволяющий выделять для каждой горутины очень маленький стек,
проверять его размер, и если его недостаточно,
выделять из кучи более крупный сегмент,
копировать туда содержимое стека,
освобождать текущий стек и перезапускать функцию

