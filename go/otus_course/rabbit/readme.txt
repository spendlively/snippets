
//Различные серверы очередей
 - Yandex Message Queue (https://cloud.yandex.ru/services/message-queue)
 - Amazon Web Services (AWS) Simple Queue Service (SQS)
 - Apache ActiveMQ
 - Apache Kafka
 - Redis (pubsub)
 - RabbitMQ

//Плюсы использования очередей
 - Слабое связывание
 - Масштабируемость
 - Эластичность
 - Отказоустойчивость
 - Гарантированная доставка
 - Гарантированный порядок доставки
 - Буферизация
 - Понимание потоков данных
 - Асинхронная связь

//Kafka
 - Стэк Apache
 - Распределённый программный брокер сообщений
 - Написан на Java/Scala
 - Придуман в Linkedin чтобы обрабатывать безумный объем данных
 - Есть коммерческая поддержка (Confluent)
 - Линейно масштабируемый
 - С гарантией упорядоченности
 - Надежный (репликация)
 - Высокодоступный (high availability)

//Гайд по Kafka
https://www.confluent.io/wp-content/uploads/confluent-kafka-definitive-guide-complete.pdf

//Kafka сущности
 - Издатель (producer)
 - Узел - содержит несколько брокеров
 - Брокер - содержит несколько топиков
 - Топик (topic) - содержит несколько partition'ов
 - Раздел (partition)
 - Подписчики (consumer), группа (group)

//Kafka Топик
 - состоит из сообщений
 - продюсер пишет сообщения
 - консьюмеры читают из топика
 - консьюмер при чтении указывает оффсет с которого он может начать читать
 - кафка не удаляет сообщения кот продьюсеры пишут в топик
 - сообщения удаляются по настройкам временного окна

//Kafka партиции
 - топик разделен на партиции
 - может разрастаться поэтому он делится на партиции
 - только одна группа консьюмеров (один процесс) может читать из одного раздела
 - чтобы неск сервисов читали один топик параллельно, нужно сделать неск партиций,
 чтобы каждый из инстансов опред сервиса читал из своего партишна

//Kafka Message
 - offset (time)
 - key (routing)
 - value (payload)

//Kafka особенности
 - лог файл в кот можно писать
 - данные которые в нее пишутся нельзя изменить
 - данные строго упорядочены

//Kafka гарантии
 - At-most-once delivery (“как максимум однократная доставка”). Сообщение не может быть доставлено больше
одного раза. При этом сообщение может быть потеряно.
 - At-least-once delivery (“как минимум однократная доставка”). Сообщение никогда не будет потеряно. При этом
сообщение может быть доставлено более одного раза.
 - Exactly-once delivery (“строго однократная доставка”). Святой грааль систем сообщений. Все сообщения
доставляются строго единожды.

//Kafka: для каких задач?
 - Message broker (ActiveMQ / RabbitMQ)
 - Трекинг активности в вебе (linkedin)
 - Сбор метрик
 - Агрегация логов
 - Stream processing (Kafka Streams)
 - Event sourcing (https://martinfowler.com/eaaDev/EventSourcing.html)
 - Storage? https://www.confluent.io/blog/okay-store-data-apache-kafka/

//Kafka: Go драйверы
https://github.com/confluentinc/confluent-kafka-go - отличная дока, librdkafka c lib
https://github.com/Shopify/sarama - плохая дока, зато чистый go
https://github.com/segmentio/kafka-go - отличный код, хорошая дока, хорошие примеры использования

//Kafka vs Rabbit
 - Rabbit меньше подходит для больших нагрузок
 - Kafka хранит все на диске
 - Rabbit хранит все в памяти
 - Kafka - журнал событий
 - Rabbit - очереди - если сообщение прочитано, его нельзя прочитать 2й раз
 - В Rabbit нет понятия offset
 - https://jack-vanlightly.com/blog/2017/12/4/rabbitmq-vs-kafka-part-1-messaging-topologies
 - https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka

//RabbitMQ сущности
 - Сообщение (message) — единица передаваемых данных, основная его часть (содержание) никак не
интерпретируется сервером, к сообщению могут быть присоединены структурированные заголовки.
 - Точка обмена (Exchange) — в неё отправляются сообщения. Точка обмена распределяет сообщения в одну или
несколько очередей. При этом в точке обмена сообщения не хранятся.
 - Очередь (queue) — здесь хранятся сообщения до тех пор, пока не будут забраны клиентом. Клиент всегда забирает
сообщения из одной или нескольких очередей.
 - Связки (bindings) - правила для роутинга сообщений

//Особенности

//RabbitMQ консьюмер
 - может забирать сообщения из нескольких очередей

//RabbitMQ типы exchange'ей
 - особенность RabbitMQ - наличие различных типов exchange'ей

//RabbitMQ Exchange: fanout exchange
 - сообщение пересылается во все очереди, которые с ним связаны
 - routing key игнорируется

//RabbitMQ Exchange: direct exchange
 - сообщения пересылаются строго по ключу routing key в соотв очередь
 - строго распределяет по опр очередям

//RabbitMQ Exchange: topic exchange
 - позволяет указывать маски в ключах
 - можно указать * или # в binding key
 - * - строго одно слово или не одного (вроде бы)
 - # - любая последовательность (вроде бы)

//Событийно-ориентированная архитектура
//Паттерн: Event notification
 - сервисы вместо того, чтобы взаимодействовать друг с другом,
общаются через очередь сообщений
 - один сервис записывает событие в очереди,
другой сервис на это событие подписывается

//Паттерн: State Transfer
 - очередь используется для репликации данных
 - у каждого сервиса база своя

//Паттерн: Event Collaboration
 - создается цепочка ивентов
 - сервисы не знают о существовании других сервисов
 - сервисы знают только о приходящих событиях
и событиях которые они сами публикуют
 - события попадают в общую очередь, все сервисы на них подписываются

//Паттерн: Event Sourcing
 - в очереди хранятся слепки состояния какого-то объекта
 - используется когда между обработкой запроса и отправкой уведомления
состояние системы может измениться извне

//Паттерн: Команды, события, запросы (3 вида событий)
 - команда - меняет состояние объекта сервиса
 - событие - что-то происходит
 - запрос - состояние не меняет (select)

//Паттерн: CQRS
 - Command Query Responsibility Segregation
 - нужно писать в оно место а читать из другого
 - чтение не должно менять состояние
 - запрос может изменить состояние

//CQRS ссылки
//Разработка транзакционных микросервисов с помощью Агрегатов, Event Sourcing и CQRS
https://habr.com/ru/company/nix/blog/322214/

//Основы CQRS
https://habr.com/ru/company/simbirsoft/blog/329970/

//Kafka vs Rabbit ссылки
//RabbitMQ против Kafka: два разных подхода к обмену сообщениями
https://habr.com/ru/company/itsumma/blog/416629/

//Understanding When to use RabbitMQ or Apache Kafka
https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka

//Apache Kafka: обзор
http://habr.com/ru/company/piter/blog/352978/

//Kafka и микросервисы: обзор
https://habr.com/ru/company/avito/blog/465315/

//Apache Kafka и миллионы сообщений в секунду
https://habr.com/ru/company/tinkoff/blog/342892/

//Apache Kafka и RabbitMQ: семантика и гарантия доставки сообщений
https://habr.com/ru/company/itsumma/blog/437446/

