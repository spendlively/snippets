Приоритет операций
1. clone new (н)	7. * / %		12. & ^ |
2. []			8. + - .		13. && ||
3. ** (п)		9. << >>		14. ?:
4. -- ++ ~ (int) @ (п) 	10. < > <= >=  (н)	15. = += -= *= **= /= .= %= |= ^= <<= >>= => (п)
5. instanсeof (н)	11. == != <> !== === (н)16. and xor or
6. ! (п)					17. ,

=============================================================================================

Ассоциативность.
Левая:
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4

Правая:
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
  
=============================================================================================

Неизвестный порядок выполнения
$a = 1;
echo $a + $a++; // может вывести и 2 и 3

$i = 1;
$array[$i] = $i++; // может задать как индекс 1, так и 2

=============================================================================================

//PHP поддерживает восемь простых типов.
Четыре скалярных типа:
boolean
integer
float (число с плавающей точкой, также известное как double)
string

Два смешанных типа:
array
object

И, наконец, два специальных типа:
resource
NULL

=============================================================================================

//Результат операции остатка от деления % будет иметь тот же знак, что и делимое
echo (5 % -3); //2
echo (-5 % 3); //-2
echo (-5 % -3); //-2

=============================================================================================

Результатом выполнения оператора присваивания является само присвоенное значение. 
Результат выполнения "$a = 3" будет равен 3

$a = ($b = 4) + 5; // $a = 9, $b = 4.

=============================================================================================

$o = &new C; //ошибка E_DEPRECATED, а в более ранних версиях - ошибку уровня E_STRICT.

=============================================================================================

Побитовые операторы
$a & $b	//Устанавливаются только те биты, которые установлены и в $a, и в $b.
$a | $b	//Устанавливаются те биты, которые установлены в $a или в $b.
$a ^ $b	//Устанавливаются только те биты, которые установлены либо только в $a, либо только в $b, но не в обоих одновременно.
~ $a	//Устанавливаются те биты, которые не установлены в $a, и наоборот.
$a << $b //Все биты переменной $a сдвигаются на $b позиций влево (каждая позиция подразумевает "умножение на 2")
$a >> $b //Все биты переменной $a сдвигаются на $b позиций вправо (каждая позиция подразумевает "деление на 2")

Биты, сдвинутые за границы числа, отбрасываются Сдвиг влево дополняет число нулями справа, сдвигая в то же время знаковый бит числа влево, что означает что знак операнда не сохраняется. Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает что знак операнда сохраняется.

Если оба операнда для &, | и ^ являются строками, то операция будет выполнена над ASCII значениями символов, составляющих эти строки, и результатом будет строка. В других случаях, оба операнда будут приведены к целому и результатом будет тоже целое число.

Если операнд для оператора ~ является строкой, то операция будет произведена над ASCII значением символов, состовляющих эту строку, и результатом будет строка. Иначе, и операнд и результат будут оперироваться как целые числа.

=============================================================================================

СРАВНЕНИЯ
Если вы сравниваете число со строкой или две строки, содержащие числа, каждая строка будет преобразована в число
Эти правила также распространяются на оператор switch.

var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0
    echo "a";
    break;
}

=============================================================================================

Преобразование типов при сравнении
Для различных типов сравнение происходит в соответствии со следующей таблицей (по порядку).

1. (null или string) и (string) //NULL преобразуется в "", числовое или лексическое сравнение
2. (bool или null) и (что угодно) //Оба операнда преобразуются в bool, FALSE < TRUE
3. (object) и (object) //Встроенные классы могут определять свои собственные правила сравнения, объекты разных классов не сравниваются, объекты одного класса - сравниваются свойства тем же способом, что и в массивах (PHP 4), в PHP 5 есть свое собственное объяснение
4. (string, resource или number) и (string, resource или number) //Строки и ресурсы переводятся в числа, обычная математика
5. (array) и (array) //Массивы с меньшим числом элементов считаются меньше, если ключ из первого операнда не найден во втором операнде - массивы не могут сравниваться, иначе идет сравнение соответствующих значений (смотри пример ниже)
6. (object) и (что угодно) //object всегда больше
7. (array) и (что угодно) //array всегда больше

=============================================================================================

Сравнение булево/null
// Булево и null всегда сравниваются как булево значение 
var_dump(1 == TRUE); //TRUE - тоже что и (bool)1 == TRUE
var_dump(0 == FALSE); //TRUE - тоже что и (bool)0 == FALSE
var_dump(100 < TRUE); //FALSE - тоже что и (bool)100 < TRUE
var_dump(-10 < FALSE);//FALSE - тоже что и (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); //NULL - (bool)NULL < (bool)-100 , тоже что и FALSE < TRUE

=============================================================================================

empty() = TRUE ()
//empty() фактически является точным эквивалентом конструкции !isset($var) || $var == false

"" (пустая строка)
0 (целое число)
0.0 (дробное число)
"0" (строка)
NULL
FALSE
array() (пустой массив)
$var; (переменная объявлена, но не имеет значения)
$var; (переменная не существует) //предупреждение не генерируется

=============================================================================================

ТЕРНАРНЫЙ ОПЕРАТОР

echo (true?'true':false?'t':'f'); //t
// на первый взгляд, следующий код должен вывести 'true'
// однако, он выводит 't'
// это происходит потому, что тернарные выражения вычисляются слева направо

// это намного более очевидная версия вышеприведенного кода
echo ((true ? 'true' : false) ? 't' : 'f');

=============================================================================================

Оператор управления ошибками
Если @ предшествует какому-либо выражению, любые сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.

Если вы установили собственную функцию обработки ошибок с помощью set_error_handler(), то она все равно будет вызвана, однако, если внутри этой функции будет вызвана функция error_reporting(), то она вернет 0, если функция, вызвавшая данную ошибку, была подавлена с помощью @.

В случае, если установлена опция track_errors , все генерируемые сообщения об ошибках будут сохраняться в переменной $php_errormsg. Эта переменная будет перезаписываться при каждой новой ошибке, поэтому в случае необходимости проверяйте ее сразу же.

Оператор @ работает только с выражениями. Есть простое правило: если что-то возвращает значение, значит вы можете использовать перед ним оператор @. Например, вы можете использовать @ перед именем переменной, произвольной функцией или вызовом include, константой и так далее. В то же время вы не можете использовать этот оператор перед определением функции или класса, условными конструкциями, такими как if, foreach и т.д.

// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or die ("Ошибка при открытии файла: сообщение об ошибке было таким: '$php_errormsg'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено

На сегодняшний день оператор "@" подавляет вывод сообщений даже о критических ошибках, прерывающих работу скрипта. Помимо всего прочего, это означает, что если вы использовали "@" для подавления ошибок, возникающих при работе какой-либо функции, в случае если она недоступна или написана неправильно, дальнейшая работа скрипта будет остановлена без каких-либо уведомлений.

=============================================================================================

ИНКРЕМЕНТ/ДЕКРЕМЕНТ

++$a //Увеличивает, затем возвращает значение $a
$a++ //Возвращает значение $a, затем увеличивает
--$a //Уменьшает $a на единицу, затем возвращает значение
$a-- //Возвращает значение $a, затем уменьшает

$a = "Z"; 
var_dump(++$a);//"AA", а не [ как в Си

$b = "A";
var_dump(++$b);//"B"

$c = "A7";
var_dump(++$c);//"A8"

$d = "A07";
var_dump(++$d);//"A08"

=============================================================================================

Логические операторы
Смысл двух разных вариантов для операторов "and" и "or" в том, что они работают с различными приоритетами

=============================================================================================

Строковые операторы
В PHP есть два оператора для работы со строками: . и .=

=============================================================================================

Операторы, работающие с массивами

$a + $b	//Объединение массива $a и массива $b.
$a == $b //TRUE в случае, если $a и $b содержат одни и те же пары ключ/значение.
$a === $b //TRUE в случае, если $a и $b содержат одни и те же паты ключ/значение в том же самом порядке и того же типа.
$a != $b //TRUE, если массив $a не равен массиву $b.
$a <> $b //TRUE, если массив $a не равен массиву $b.
$a !== $b //Тождественно не равно

$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");
$c = $a + $b;
var_dump($c); //array("a" => "apple", "b" => "banana", "c" => "cherry");

==================================================================================

instanceof
работает для дочерних/родительских классов и интерфейсов

class ParentClass{}
class MyClass extends ParentClass{}
$a = new MyClass;
var_dump($a instanceof MyClass); //true
var_dump($a instanceof ParentClass); //true

//Можно использовать с объектом
var_dump($a instanceof $b);

//Не работает с константами
var_dump(FALSE instanceof stdClass); //PHP Fatal error:

//Можно так
$d = 'NotMyClass';
var_dump($a instanceof $d); // нет фатальной ошибки

==================================================================================


