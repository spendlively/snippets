
///////////////////////////
//Память процесса в linux//
///////////////////////////
//Виртуальная память
 - у каждого процесса своя виртуальную память
 - каждый процесс видит собственное адресное пространство (независимую виртуальную память)
 - у каждого процесса память адресуется от 0 до скольки позволяет разрядность процессора
 - на 32 битных машинах каждая программа может адресовать до 4Гб памяти
 - виртуальная память маппится на физическую память и своп
 - ядро ос настраивает таблички маппинга
 - процессор использует эти таблички и отображает виртуальную память на реальную

///////////////////////////////
//Виртуальная память процесса//
///////////////////////////////
 - 4гб на 32х битной машине

//Просмотреть структуру памяти процесса
cat /proc/{pid}/maps | tac

//Как linux работает с памятью
https://www.youtube.com/watch?v=bhdkFPGhxfI

//Kernel space
 - 1гб на 32х битной машине
 - старший гигабайт каждого процесса отводится под память ядра (функции и структуру ядра ос)
 - сам процесс доступа к нему не имеет
 - при попытке обратиться к этой kernel-памяти процесс получит segmentation fault

//User space
 - 3гб на 32х битной машине
 - состоит из сегментов (сверху вверх)

//Расположение сегментов в сторону УВЕЛИЧЕНИЯ адресов (от 0)
 - Text segment (ELF) - машинный код  программы
 - Data сегмент - инициализированные статические переменные
 - BSS сегмент - неинициализированные статические переменные
 - куча
 - memory mapping segment
 - стек
 - Kernel space

//Стек
 - растет в сторону уменьшения адресации (к 0)
 - растет навстречу куче
 - локальные переменные функции
 - память в стеке выделяется автоматически
 - в линуксе есть RLIMIT_STACK = 8мб больше которого нельзя получить стек

//Куча
 - растет в сторону увеличения адресации (от 0)
 - растет навстречу стеку
 - долгоживущие объекты, кот живут дольше чем функция

//Memory mapping segment
 - сегмент между стеком и кучей
 - динамические библиотеки
 - позволяет отдельные адреса маппить на динамические библиотеки либо на оперативную память

/////////////////////////
//Работа с памятью в go//
/////////////////////////
//Стек горутины в go
 - для каждой горутины выделяется свой маленький стек
 - системный стек тоже используется для вспомогательных целей: чтения файлов и пр системные вызовы
 - основной код программы исполняется в маленьких отдельных стеках
 - go compile -s - транслировать исходник в промежуточный ассемблер
 - (перед функцией //go:inline - чтобы)
 - изначально стек горутины в го занимает 2кб и растет при необходимости
 - стек го состоит из фреймов
 - внутри фрейма хранятся все переменные кот есть в функции:
    - входящие параметры
    - локальные переменные
    - адрес возврата
    - предыдущее значение стек поинтера
 - выделение памяти внутри функции практически бесплатное (1 команда)
 - переменные на стеке живут столько, сколько живет фрейм в функции - до конца выполнения функции
 - память для стека горутин выделяется в куче процесса

//Если стек переполнится (большая рекурсия)
 - стек горутины может реаллоцироваться - перемещаться из одной области памяти в другую
 - создается новый стек
 - выделяется новый кусок памяти (в 2 раза больше)
 - содержимое старого стека копируется

////////////////////////////////
//Выделение памяти в куче в go//
////////////////////////////////
//Примитивы памяти
 - Арена (arena) - несколько спанов
 - Спан (span) - несколько страниц
 - Страница (page)

//Арена (arena)
 - go запрашивает у ОС память большими аренами по 64 мб
 - чтобы не делать много системных вызовов
 - внутри арены память делится на страницы по 8кб

//Страница (page)
 - минимальный элемент аллокации
 - кусочек арены 8кб
 - подряд идущие страницы объединяются в спаны - 1 стр, 2, и т.д.

//Спаны (span)
 - несколько подряд идущих страниц
 - в go есть 67 вариантов спанов
 - размер спана может быть от 8 кб до 32 кб
 - размер объекта внутри спана может быть от 8 б до 32 кб
 - количество объектов внутри спана может быть от 1 до 1024 кб
 - runtime/sizeclasses.go
 - переменные до 8 байт хранятся о спанах 1го типа
 - переменные до 16 байт хранятся о спанах 2го типа и т.д.

//Алгоритм выделения памяти
 - просим у рантайма память под объект N-байт
 - рантайм ищет подходящий спан
 - внутри спана ищется свободное место по битовой маске в структуре спана (allocBits)
 - место выделяется и отмечается в битовой маске как занятое

//Поиск свободного спана
 - у каждого процессора есть кэше спанов mcache (Core1)
 - свободные спаны ищутся в кэше процессора mcache
 - если в mcache нет свободных спанов, они берутся из mheap
 - в mheap лежат
    - несколько списков свободных спанов mcentral (2-связный список спанов)
    - раздел MTreap с большими свободными спанами
    - раздел arenas с аренами
 - если в mcentral нет свободных спанов, ищется спан большего размера в mTreap и делится
 - если в mTreap нет свободных спанов, создаем новую арену и в ней создается большой спан
 - новый спан помещается в mTreap и по необходимости делится

//Если горутина перепрыгнет на другое ядро
 - при аллокации памяти она будет использовать другой кэш

//Алгоритм освобождения памяти
 - ячейка в спане помечается как неиспользуемая (бит в маске allocBits)
 - как только в спане появляется хоть одно свободное место,
он из списка занятых помещается в список свободных (mheap.mcentral)


//////////////////////////
//GC - Garbage Collector//
//////////////////////////
 - алгоритм подсчета ссылок на объект НЕ ИСПОЛЬЗУЕТСЯ

//Алгоритм отслеживание неиспользуемых объектов (Mark and Sweep) - УСТАРЕВШИЙ
 - работает с остановкой кода (чтобы не потерять ссылки)
 - берутся все глобальные объекты и активные горутины
 - ищутся все объекты, на которые ссылаются глобальные объекты и активные горутины
 - объекты до которых невозможно достучаться помечаются неиспользуемыми (Mark)
 - в какой-то момент весь рантайм должен остановиться, чтобы избежать потери ссылок,
при очистке неиспользуемых объектов - что считается НЕПРИЕМЛИМЫМ


//Tricolor Mark and Sweep - АКТУАЛЬНЫЙ
 - основную работу выполняет конкурентно
 - останавливает работу горутин иногда и ненадолго
 - у объекта есть 3 состояния
    - черный - используемые (сохранить)
    - серый - могут стать черными, не удаляются
    - белый - неиспользуемые (удалить)
 - объекты, на кот ссылаются глобальные переменные и горутины помечаются СЕРЫМ (фаза Mark)
 - объекты, на кот ссылаются серые объекты красятся тоже в СЕРЫЙ, а уже серые в ЧЕРНЫЙ (фаза Mark)
 - для неиспользуемых объектов соответствующий сегмент в спане
отмечается в битовой маске как неиспользуемый (фаза Sweep)

//////////////////
//Фазы работы GC//
//////////////////
runtime.gcStart - точка входа в Garbage collector.

//Завершение очистки
 - завершение очистки Span-ов из mheap_.sweepSpans[1-sg/2%2]
 - запуск горутин gcBgMarkWorker для разметки объектов

//_GCMark
 - stop the world
 - завершение очисти Span-ов
 - инициализация очереди разметки корневыми объектами
 - start the world
 - ожидание завершения всех gcBgMarkWorker

//_GCmarktermination
 - stop the world
 - завершение разметки Span-ов
 - start the world

//_GCoff
 - увеличивается итерация GC mheap_.sweepdone
 - фоновая очистка Span-ов из mheap_.sweepSpans[1-sg/2%2]


//////////////////////
//Моменты запуска GC//
//////////////////////
 - периодически из потока sysmon , если прошло достаточно много времени с последнего запуска
 - после выделения памяти, если выделен большой Span или не удалось выделить быстро
 - при ручном вызове runtime.GC()



//Как определить, где go выделит память
 - никак
 - примерно количество аллокаций можно узнать бенчмарками
 - кое-что можно узнать с помощью эскейп анализа

//Эскейп анализ (Escape Analysis)
 - go build -gcflags="-m"
 - ./main.go:12:2: moved to heap: x
 - ./main.go:7:14: *n escapes to heap

//io.Reader
//Почему io.Reader имеет такой интерфейс?
type Reader interface {
    Read(p []byte) (n int, err error)
}
 - в клиентском коде мы сможем выделить память (если повезет на стеке)
 - внутри Read ничего аллоцировать не придется
 - не придется ничего копировать из функции в функцию



