////////////////////////////////////////////////////
//////////////////Описание модуля///////////////////
////////////////////////////////////////////////////
//1.
Код модуля объявляет две функции:
инициализации (md_init) и завершения (md_exit);

//2.
Имена функций, выполняющих эти задачи,
объявляются в макросах module_init() и module_exit();

//3.
Функция инициализации выполняется при загрузке модуля в ядро,
если эта функция возвращает нулевое значение (успех),
то код модуля остаётся резидентным и выполняет дальнейшую работу

//4.
Функция завершения по своему прототипу не имеет возвращаемого значения,
поэтому, начавшись, она уже не имеет механизмов сообщить о своём неудачном выполнении

//5.
Большинство операций над модулями (insmod, rmmod, modprobe) требуют прав root,
но некоторые индикативные команды (lsmod) могут выполняться и от имени ординарного пользователя.

//6.
Существует ещё один, не документированный, способ описания этих функций:
воспользоваться их предопределёнными именами, а именно init_module() и cleanup_module():

int init_module( void ) { ... }
void cleanup_module( void ) { ... }

//При такой записи необходимость в использовании макросов module_init() и module_exit() отпадает,
//а использовать модификатор static с этими функциями нельзя
//(именно эти имена и используются при загрузке и удалении модуля).





////////////////////////////////////////////////////
/////////////////Сборка и подключение///////////////
////////////////////////////////////////////////////
//Компиляция
make

//Результат
В результате скомпилируются файлы объектного формата компилятора gcc,
расширенные некоторыми дополнительными символами:
md1.ko md2.ko

//Для отладки
dmesg -w


//Установка модулей (сначала вызываемый модуль, затем вызывающий)
sudo insmod md1.ko
sudo insmod md2.ko

//Просмотр вывода dmesg
//Т.к. в пространстве ядра нет управляющего ткрминала, куда обычно выводит printf
//printk направляет вывод демону системного журналирования
dmesg

//Проверка, чтобы модули загрузились в ядро
lsmod | grep md

//Удаление модулей (в обратном порядке)
sudo rmmod md2.ko
sudo rmmod md1.ko
lsmod | grep md





////////////////////////////////////////////////////
///////////////////Комментарии//////////////////////
////////////////////////////////////////////////////
//1. API ядра
 - множество экспортируемых имён ядра
 - любой модуль может использовать в своём коде
любые экспортируемые другим модулем процедуры или структуры

char *md1_data = "Привет мир!";
EXPORT_SYMBOL( md1_data );



//2. Прямой абсолютный адрес
Модуль md2, использующий экспортируемое имя,
связывается с этим именем по прямому абсолютному адресу.
Как следствие этого, любые изменения (новая сборка),
вносимые в ядро или экспортирующие модули,
делают собранный модуль непригодным для использования.
Поэтому бессмысленно предоставлять модуль в собранном виде —
он должен собираться только на месте использования.



//3. Неэкспортированные имена
Модуль сможет использовать только те имена, которые явно экспортированы.
В модуле md1 (original) специально показаны два других имени: md1_local()
является локальным именем (модификатор static), непригодным для связывания,
а имя md1_noexport() не объявлено как экспортируемое имя и также не может быть использовано вне модуля.

