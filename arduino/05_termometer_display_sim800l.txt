#include <SoftwareSerial.h>
#include <OneWire.h>

SoftwareSerial sim(10, 11);
int _timeout;
String _buffer;
String number = "+79232375741";

OneWire ds(2);

#include <LiquidCrystal_I2C.h>
#if defined(ARDUINO) && ARDUINO >= 100
#define printByte(args)  write(args);
#else
#define printByte(args)  print(args,BYTE);
#endif
LiquidCrystal_I2C lcd(0x27,16,2);

void setup(){
    pinMode(8, OUTPUT);
    digitalWrite(8, HIGH);
    pinMode(7, OUTPUT);
    digitalWrite(7, HIGH);
    pinMode(4, OUTPUT);
    digitalWrite(4, LOW);
    lcd.init();
    lcd.backlight();

//    Serial.begin(9600);

    Serial.begin(9600);
    _buffer.reserve(50);
//    Serial.println("Sistem Started...");
    sim.begin(9600);
    delay(1000);
//    Serial.println("Type s to send an SMS, r to receive an SMS, and c to make a call");
}

int i = 0;
String msg = "";

void loop(){

  i = i + 1;

    // Определяем температуру от датчика DS18b20
  byte data[2]; // Место для значения температуры

  ds.reset(); // Начинаем взаимодействие со сброса всех предыдущих команд и параметров
  ds.write(0xCC); // Даем датчику DS18b20 команду пропустить поиск по адресу. В нашем случае только одно устрйоство
  ds.write(0x44); // Даем датчику DS18b20 команду измерить температуру. Само значение температуры мы еще не получаем - датчик его положит во внутреннюю память

  delay(1000); // Микросхема измеряет температуру, а мы ждем.

  ds.reset(); // Теперь готовимся получить значение измеренной температуры
  ds.write(0xCC);
  ds.write(0xBE); // Просим передать нам значение регистров со значением температуры

  // Получаем и считываем ответ
  data[0] = ds.read(); // Читаем младший байт значения температуры
  data[1] = ds.read(); // А теперь старший

  // Формируем итоговое значение:
  //    - сперва "склеиваем" значение,
  //    - затем умножаем его на коэффициент, соответсвующий разрешающей способности (для 12 бит по умолчанию - это 0,0625)
  float t =  ((data[1] << 8) | data[0]) * 0.0625;
  float h = 0.0;

//  Serial.println(t);
  lcd.clear();


  if (isnan(h) || isnan(t)) {
    lcd.print("Error");
    return;
  }

  lcd.setCursor(0, 0);
  lcd.print("Humd: " + String(h, 2) + "%");

  lcd.setCursor(0, 1);
  msg = "Temp: " + String(t, 2) + "C";
  lcd.print(msg);

  if (i >= 60 ){
      sim.println("AT+CMGF=1");    //Sets the GSM Module in Text Mode
      delay(200);
      sim.println("AT+CMGS=\"" + number + "\"\r"); //Mobile phone number to send message
      delay(200);
      sim.println(msg);
      delay(100);
      sim.println((char)26);// ASCII code of CTRL+Z
      delay(200);

    sim.println("AT+CMGF=1");
    delay(200);
    sim.println("AT+CPIN=\"0000\"");
    delay(200);
    sim.println("AT+CSMP?");
    delay(200);
    sim.println("AT+CMGS=\"+79232375741\"\r");
    delay(200);
    sim.println(msg);
    delay(100);
    sim.println((char)26);
    delay(200);
    _buffer = _readSerial();

      i = 0;
  }
}