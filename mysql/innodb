
/////////////////////////////////////////////////////////////////
/////////////////////////ТРЕБОВАНИЯ ACID/////////////////////////
/////////////////////////////////////////////////////////////////
- Atomicity - Атомарность
   - транзакции
- Consistency - согласованность
- Isolation - изолированность
   - блокировки
   - MVCC - multiversion concurrency control
- Durability - долговечность





/////////////////////////////////////////////////////////////////
/////////////////////////////Innodb//////////////////////////////
/////////////////////////////////////////////////////////////////
 - любая операция - транзакция
 - Default value: AUTOCOMMIT = 1
 - При явном описании транзакции происходит: START TRANSACTION SET AUTOCOMMIT = 0
 - блокировка строки = блокировка индекса (или номера строки)
 - блокировки ставятся не в начале транзакции, а в ходе выполнения на каждый запрос
 - блокировки сбрасываются после COMMIT/ROLLBACK/ERROR





/////////////////////////////////////////////////////////////////
////////4 проблемы параллельного выполнения транзакций///////////
/////////////////////////////////////////////////////////////////
 - потерянное обновление
    - value = 10
    - 1-я транзакция update +5
    - 2-я транзакция update -5
    - на выходе получаем либо 5, либо 15 (а должно остаться 10)
    - проблема: последняя транзакция перетерла значение первой
 - грязное чтение
    - value = 10
    - 1-я транзакция update +5
    - 2-я транзакция select value - возвращает 15 (возвращает незакомиченные изменения)
    - 1-я транзакция update крэшится и откатывает изменение на 10
    - проблема: получили неправильное значение
 - неповторяющееся чтение
    - value = 10
    - 1-я транзакция select value - возвращает 10
    - 2-я транзакция коммитит update +5
    - 1-я транзакция select value - возвращает 15
    - проблема: получили разные значения
 - фантомное чтение (всегда про промежутки)
    - value = 10
    - 1-я транзакция select value between 10 and 20
    - 2-я транзакция insert value 15, commit
    - 1-я транзакция select value between 10 and 20
    - проблема: получен другой набор строк





/////////////////////////////////////////////////////////////////
///////////////////////УРОВНИ ИЗОЛЯЦИИ///////////////////////////
/////////////////////////////////////////////////////////////////
1 - уровень изоляции решает эту проблему
0 - уровень изоляции НЕ решает эту проблему

УРОВЕНЬ (ansi sql-92)           Потерянное обновление   Грязное чтение  Неповторяющееся чтение  Фантомное чтение
 1. Read uncommited             1                       0               0                       0
 2. Read commited               1                       1               0                       0
 3. Repeatable read (default)   1                       1               1                       0
 4. Serializable                1                       1               1                       1





/////////////////////////////////////////////////////////////////
/////////////////////////////БЛОКИРОВКИ//////////////////////////
/////////////////////////////////////////////////////////////////
 - на уровне строк
    - shared - (S)
       - можно читать
       - нельзя изменять/удалять
    - exclusive - (X)
       - нельзя ничего, даже читать
 - на уровне таблиц - более высокоуровневые (рулит сама субд) - блокировки о намерениях
    - intention shared - (IS)
    - intention exclusive - (IX)
 - insert locks, auto-inc locks, schema lock

 //Совместимость блокировок
 С - совместимы
 К - конфликт
        X   IX  S   IS
 X      К   К   К   К
 IX     К   С   К   С
 S      К   К   С   С
 IS     К   С   С   С

//Пользовательскте блокировки (Блокировки работают только в транзакции, Only if AUTOCOMMIT = 0)
 - SELECT ... LOCK IN SHARE MODE (set S lock)
 - SELECT ... FOR UPDATE (set X lock)

//Типы блокировок
 - Record lock - блокировка индекса записи
 - Gap lock - блокировка промежутка до/после индексной записи
 - Next key lock - блокировка индекса и промежутка





/////////////////////////////////////////////////////////////////
////////////////////////////ПРИМЕРЫ//////////////////////////////
/////////////////////////////////////////////////////////////////
 - SELECT FROM - неблокирующее чтение (согласованное чтение) (кроме уровня serializable)
 - SELECT FROM ... LOCK IN SHARE MODE - S next-key lock
 - SELECT FROM ... FOR UPDATE - X next-key lock
 - UPDATE WHERE - X next-key lock
 - DELETE FROM - X next-key lock
 - INSERT INTO - X record lock
 - p.s. если по уникальному ключу, то вместо next-key обычный record lock





/////////////////////////////////////////////////////////////////
////////////////////////////ЧТЕНИЕ///////////////////////////////
/////////////////////////////////////////////////////////////////
Согласованное чтение
 - доступны только те изменения, которые внесены транзакциями и зафиксированы
 - согласованные чтения согласованы по отношению друг к другу в пределах одной транзакции
 - чтобы получить более свежую копию для своих запросов, нужно зафиксировать текущаю транзакцию и направить новые запросы
 - режим по умолчанию, в котором в innodb обрабатываются операторы SELECT.
 - не устанавливаются блокировкм на таблицы, к которым обращен запрос
 - другие пользователи могут вносить изменения в эти таблицы

Чтение в режиме совместного доступа (с блокировкой SELECT ... LOCK IN SHARE MODE)
 - не позволяет другим пользователям обновить или удалить читаемую строку
 - снимается во время фиксации
 - пример - добавляем данные в таблицу детей, блокируя таблицу родителей на изменение, чтобы никто не удалил в ней запись:
    - стартуем транзакцию
    - ищем запись в таблице родителей IN SHARE MODE чтобы ее не могли удалить или изменить
    - добавляем запись в таблицу детей
    - коммитим изменения

Чтение с эксклюзивной блокировкой SELECT ... FOR UPDATE
 - не позволяет другим пользователям читать, обновить или удалить читаемую строку
 - очно такую же блокировку ставит обычный UPDATE, когда считывает данные для обновления
 - снимается во время фиксации
 - пример - обновляем счетчик, блокируя таблицу на чтение и изменение, чтобы 2 пользователя не получили одно значение
    - стартуем транзакцию
    - читаем в режиме блокировки SELECT COUNTER_FIELD FROM CHILD_CODES FOR UPDATE;
    - обновляем счеткик UPDATE CHILD_CODES SET COUNTER_FIELD = COUNTER_FIELD + 1;
    - коммитим изменения

Блокировка следующего ключа (предотвращение появления фантомов)
 - если у пользователя имеется совместная или эксклюзивная блокировка записи R в индексе,
то другой пользователь не может вставить новую индексную запись перед R в порядке следования индексов





/////////////////////////////////////////////////////////////////
////////////////////КАК ИЗБЕЖАТЬ ВЗАИМОБЛОКИРОВОК////////////////
/////////////////////////////////////////////////////////////////
 - Если используется SELECT ... FOR UPDATE или LOCK IN SHARE MODE,
попробуйте использовать более низкий уровень изоляции READ COMMITED
 - Если можно допустить, чтобы SELECT возвращал данные из старого снимка,
не добавляйте к выражению FOR UPDATE или LOCK IN SHARE MODE
и используйте уровень изоляции READ COMMITTED
- Используйте SHOW INNODB STATUS для определения причины последней взаимоблокировки
- Всегда подготавливайте перезапуск транзакции, если произошел откат из-за взаимоблокировки
- Маленькие транзакции меньше склонны к противоречиям





/////////////////////////////////////////////////////////////////
/////////////////////////УРОВНИ ИЗОЛЯЦИИ/////////////////////////
/////////////////////////////////////////////////////////////////
READ UNCOMMITED (самый слабый уровень)
 - Все запросы SELECT читают в неблокирующей манере
 - Изменения незавершенной транзакции могут быть прочитаны в других транзакциях и откачены (грязное чтение)

READ COMMITED
 - Согласованное чтение ничего не блокирует, но каждый раз происходит из свежего снэпшота
 - Блокирующее чтение (SELECT… FOR UPDATE/LOCK IN SHARE MODE), UPDATE и DELETE блокирует только искомые индексные записи (record lock)
 - Возможна вставка параллельным потоком записей в промежутки между индексами

REPEATABLE READ
 - Согласованное чтение (SELECT) ничего не блокирует, читает строки из снэпшота, который создается при первом чтении в транзакции
 - Для блокирующего чтения (SELECT… FOR UPDATE/LOCK IN SHARE MODE), UPDATE и DELETE
    - Если условие уникально (WHERE id=42), то блокируется только найденная индексная запись (record lock)
    - Если условие с диапазоном (WHERE id > 42), то блокируются весь диапазон (gap lock или next-key lock).

SERIALIZABLE (самый строгий уровень)
 - REPEATABLE READ +
    - Если autocommit выключен или при явном старте транзакции все простые запросы SELECT неявно превращаются в SELECT… LOCK IN SHARE MODE
    - Если autocommit включен каждый SELECT идет в отдельной транзакции
