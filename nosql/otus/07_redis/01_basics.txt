
//Redis
 - данные хранятся в памяти
 - хорошо держит высокую нагрузку
 - работает в одном потоке - исключает блокировки
 - атомарность транзакций
 — заточен под быстрый произвольный доступ
 — выполняет атомарные операции над данными
 — позволяет перенести часть вычислений с клиента

//Минусы
 - не использует плюсы многоядерных систем
 - из коробки нет: поиска, индексов, внешних ключей, джойнов
 - нет возможности стоить сложные запросы (придется делать неск)

//Структуры данных
 — строки
 — хэш-таблицы
 — списки
 — множества
 — упорядоченные множества
 — и т.д.

//Совместимость типов даннвх
 - у каждого типа данных свой набор команд
 - эти команды между собой несовместимы

//////////////////////////
//Выбор структуры данных//
//////////////////////////
Записи          Порядок не важен        Порядок важен
Неуникальные    -                       Список
Уникальные      Множество               Уп. множество

//С помощью чего можно реализовать…
 - Хранение сессий - Строки
 - Общие знакомые Стаса и Жени - Множества
 - 10 лучших постов Стаса - Упорядоченные множества
 - 10 последних постов Стаса - Списки
 - …с датой, названием и тэгами - Хэш-таблицы (доп. запросы)

//Key/Value
 - ключ - всегда строка
 - значение - разные типы
 - хранятся и те и другие в виде строк
 - ключи имеют ttl - по истечении и ключ, и значение будут удалены
 - размер и ключа, и значения могут быть до 512 Мб
 - значения бинарно безопасные - можно класть бинарники как есть
 - get несуществующего ключа вернет (nil)
 - в Value нельзя положить 1, все равно положится "1"

//Bool
 - целесообразно хранить как "1" и "0"

//Сценарии использования
 — кэширование
 — хранение сессий
 — АТОМАРНЫЕ!!! счётчики

//Сценарии использования TTL
 - удаление исторических данных
 - кэш
 - сессии
 - одноразовые коды
 - куки
 - ключи
 - токены


//Именование ключей
 — осмысленное название
 — идём от общего к частному
 — user:12:token
 — двоеточия в имени ключа нужны только для человека


//Хэш-таблица
 - доступ к полю тоже за О(1)
 - нет вложенности
 - не схемы данных
 - GET user:1 для hset'а вернет ошибку
 - порядок полей сохраняется если количество полей не превышает hash-max-ziplist-entries
 - setting 10 on fly: CONFIG SET hash-max-ziplist-entries 10
 - при превышении параметра, encoding: ziplist -> hashtable

//Списки
 - сценарии использования
     — хранение событий в хронологическом порядке
     — логирование
     — event sourcing
 — список со временем будет раздуваться
 — частая практика — обрезать его длину после вставки

//Множества
 - уникальные значения
 - сценарии использования
    — аналитика
    — хранение связей между сущностями
    — таксономия (тэги)
 - если в множество положить 1 и "1" -> будет одно значение 1

//Упорядоченные множества
— содержат только уникальные значения
— для каждого значения указывается счёт (score)
— значения автоматически сортируются по счёту
— время добавления и поиска – O(log n)
- Сценарии использования
    — рейтинги
    — аналог индекса в РСУБД (значение — ключ сущности)
- Важно помнить
    — для вывода в порядке убывания используются zrev*
    — если обновить рейтинг, он перезапишет старый


//Битовые строки
— это обычные строки
— к отдельным битам можно обращаться по индексу
— есть все основные битовые операции
— большинство команд выполняется за O(N)
— Сценарии использования
    — аналитика
    — фильтрация с подсчётом
- Важно помнить
    — при установке "далёкого" бита размер строки резко увеличивается
    — для разреженных данных лучше подходят обычные множества
