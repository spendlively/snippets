

//Обобщения
 - не работают с примитивными типами данных


//обобщенный класс
public class Gen<T> {
   private T value;
   Gen(T value) {
       this.value = value;
   }
   public T getValue() {
       return this.value;
   }
}

public class Main {
   public static void main(String[] args) {
       Gen<Integer> gen = new Gen<>(1);
       System.out.println(gen.getValue());
       Gen<String> gen2 = new Gen<>("qwerty");
       System.out.println(gen2.getValue());
   }
}


//обобщенный метод
public class Main {

   public static <T> T getValue(T value){
       return value;
   }

   public static void main(String[] args) {
       System.out.println(Main.getValue(1));
       System.out.println(Main.getValue("QWERTY"));
   }
}

///////////////////////////////////////////////////////////////////////
/////////////////////////////////ТЕОРИЯ////////////////////////////////
///////////////////////////////////////////////////////////////////////

https://m.habr.com/ru/company/sberbank/blog/416413/

//////////////////////////////////////////////////////////
/////////////////////////Дженерики////////////////////////
//////////////////////////////////////////////////////////
//Коротко
 - введены с java 5.0
 - благодаря дженерикам ошибки связанные с некорректным использованием типов
обнаруживаются на энапе компиляции
 - массивы в java ковариантны (Integer[] является подтипом Number[], Integer[] можно присвоить в Number[])
 - дженерики в java инвариантны (List<Integer> НЕ является подтипом List<Number>, Integer[] НЕЛЬЗЯ присвоить в Number[])
 - при использовании wildcard дженерики могут буть инвариантными, ковариантными и контрвариантными

//Советы - что использовать и когда
 - Если необходимо читать из контейнера,
то используйте wildcard с верхней границей "? extends"
 - Если необходимо писать в контейнер,
то используйте wildcard с нижней границей "? super"
 - Не используйте wildcard, если нужно производить и запись, и чтение.
 - Не используйте Raw типы!
 - Если аргумент типа не определен, то используйте wildcard <?>



/////////////////////////////////////////////////////////
//////////Принцип подстановки барбары лисков/////////////
/////////////////////////////////////////////////////////
//1. Определение принципа подстановки Барбары Лиспов
Если Child является подтипом Parent,
тогда объекты типа Parent в программе
могут быть замещены объектами типа Child
без каких-либо изменений желательных свойств этой программы

//Правила подмен типов
ТИП             ПОДТИП          (ПОДТИП можно заменить на ТИП)
Number          Integer         (Integer -> Number)
List<E>         ArrayList<E>    (ArrayList<E> -> List<E>)
Collection<E>   List<E>         (List<E> -> Collection<E>)
Iterable<E>     Collection<E>   (Collection<E> -> Iterable<E>)

//2. Примеры подмены типов в Java
Number n = Integer.valueOf(42);
List<Number> aList = new ArrayList<>();
Collection<Number> aCollection = aList;
Iterable<Number> iterable = aCollection;



///////////////////////////////////////////////////////////
////Ковариантность, контравариантность и инвариантность////
///////////////////////////////////////////////////////////
//1.1. Ковариантность
Сохранение иерархии наследования исходных типов в производных типах в том же порядке

Если Кошка — это подтип Животные, то
Множество<Кошки> — это подтип Множество<Животные>.

Следовательно, с учетом принципа подстановки можно выполнить такое присваивание:
Множество<Животные> = Множество<Кошки>


//1. Определения что есть что
//1.2. Контравариантность
Это обращение иерархии исходных типов на противоположную в производных типах.

Если Кошка — это подтип Животные,
то Множество<Животные> — это подтип Множество<Кошки>

Следовательно, с учетом принципа подстановки можно выполнить такое присваивание:
Множество<Кошки> = Множество<Животные>


//1.3. Инвариантность
Это отсутствие наследования между производными типами.

Если Кошка — это подтип Животные,
то Множество<Кошки> не является подтипом Множество<Животные> и
Множество<Животные> не является подтипом Множество<Кошки>.


//2. Ковариантность в Java
//2.1. Массивы в Java ковариантны:
Если Strings — подтип Object, то
Тип Strings[] является подтипом Object[]

//Пример присваивания:
String[] strings = new String[]{"a", "b", "c"};
Object[] arr = strings;
for (Object o : arr) System.out.print(o); //abc
//Так как массивы ковариантны, (Integer тоже подтип Object)
//компиляция выполнится без ошибок и ошибка произойдет на этапе выполнения
a[0] = 42; //ArrayStoreException


//2.2. Дженерики инвариантны
Если Integer — подтип Number, то
Тип List<Integer> НЕ является подтипом List<Number>.
List<Integer> является подтипом только самого себя.

//Пример
List<Integer> ints = Arrays.asList(1, 2, 3);
//Compile-time error
//Incompatible types: List<Integer> cannot be converted to List<Number>
List<Number> nums = ints;



////////////////////////////////////////////////////////////////
///////////////////////////Wildcards////////////////////////////
////////////////////////////////////////////////////////////////
//1. Wildcard или символ подстановки это
запись вида <? extends ...> или <? super ...>

//2. wildcard <? extends ...>
 - wildcard с верхней границей (extends)
 - дженерики с extends ковариантны
 - List<? extends Number> может содержать объекты
класса Number или наследника от Number
 - из <? extends ...> можно только читать объекты
 - в <? extends ...> можно писать только NULL

//Пример extends
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;


//3. wildcard <? super ...>
 - wildcard с нижней границей (super)
 - дженерики с super контрвариантны
 - List<? super Integer> может содержать объекты
класса Integer или родителя Integer
 - в <? super ...> можно только писать объекты
 - из <? super ...> нельзя прочитать ничего, кроме объекта класса Object

//Примеры super
List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;


/////////////////////////////////////////////////////////////////////
////////////////////////////////PECS/////////////////////////////////
/////////////////////////////////////////////////////////////////////
Producer Extends Consumer Super
 - принцип для определения, что может wildcard с extends, а что wildcard с super

//extends
 - wildcard с extends, то это producer
 - он только предоставляет элементы из контейнера, а сам ничего не принимает

//super
 - wildcard с super — то это consumer
 - он только принимает, а предоставить ничего не может



///////////////////////////////////////////////////////////////////////
///////////////////////////<?> и Raw типы//////////////////////////////
///////////////////////////////////////////////////////////////////////
//Неограниченный wildcard <?>
- Запись вида Collection<?> равносильна Collection<? extends Object>
- может содержать объекты любого класса, так как все классы в Java наследуются от Object
- подстановка называется неограниченной

//Raw тип
Если мы опустим указание типа, например, как здесь:
ArrayList arrayList = new ArrayList();
то, говорят, что ArrayList — это Raw тип параметризованного ArrayList<T>.

Используя Raw типы, мы возвращаемся в эру до дженериков и сознательно отказываемся от всех фич, присущих параметризованным типам.

//ворнинги при использовании raw типа
ArrayList<String> strings = new ArrayList<>();
ArrayList arrayList = new ArrayList();
arrayList = strings; // Ok
strings = arrayList; // Unchecked assignment
arrayList.add(1); //unchecked call



/////////////////////////////////////////////////////////////////
////////////////////////Wildcard Capture/////////////////////////
/////////////////////////////////////////////////////////////////
//Wildcard Capture - захват символа подстановки
 - паттерн для создания обобщенного метода с переменной типа <T>
 - применяется когда нужно использовать get и set,
а обычный wildcard поддерживает либо get, либо set

//пример
public static void reverse(List<?> list) {
  rev(list);
}

private static <T> void rev(List<T> list) {
  List<T> tmp = new ArrayList<T>(list);
  for (int i = 0; i < list.size(); i++) {
    list.set(i, tmp.get(list.size()-i-1));
  }
}
//Если мы можем захватить тип этих объектов и присвоить его переменной типа X,
то можем заключить, что T является X.



//////////////////////////////////////////////////////////////////////
///////////////////////////Переменные типа////////////////////////////
//////////////////////////////////////////////////////////////////////
//Переменная типа
 - это неквалифицированный идентификатор,
который можно использовать в качестве типа в теле класса или метода.
 - Переменная типа может быть ограничена ТОЛЬКО сверху (в отличае от wildcard)
 - <T extends Comparable<T>> - определяет T (переменную типа),
ограниченную сверху типом Comparable<T>
 - в этом примере T зависит от самого себя,
это называется recursive bound — рекурсивная граница
 - Переменная типа может быть ограничена только сверху одним или несколькими типами

//Пример
public static <T extends Comparable<T>> T max(Collection<T> coll) {
  T candidate = coll.iterator().next();
  for (T elt : coll) {
    if (candidate.compareTo(elt) < 0) candidate = elt;
  }
  return candidate;
}



/////////////////////////////////////////////////////////////
///////////////////////Multiple bounds///////////////////////
/////////////////////////////////////////////////////////////
 - множественные ограничения
 - Записывается через символ "&"
 - В случае множественного ограничения левая граница (первое ограничение)
используется в процессе затирания (Type Erasure)
 - <Object & Comparable<? super T>> - образует тип пересечения Multiple Bounds

//Пример
<T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
 - тип, представленный переменной типа T,
должен быть ограничен сверху классом Object
и интерфейсом Comparable.


Type Erasure.
Что это?

Reifiable типы.
Что это?

Unchecked Warnings.
Что это?

Heap Pollution.
Что это?

Reflection.
Что это?

Type Inference.
Что это?


