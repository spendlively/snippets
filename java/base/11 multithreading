
Состояния потоков
 - выполняется
 - готов к выполнению
 - приостановлен
 - возобновлен
 - заблокирован
 - прерван (не может быть возобновлен)


Синхронизация
Для предотвращения записи данных в одном потоке ис­полнения, 
когда в другом потоке исполнения выполняется их чтение
в java реализован механизм управления - монитор - маленький ящик, 
одновременно хранящий только один поток исполне­ния.

у каждого объекта имеется свой неявный монитор, вход в который осуществляется автоматически.

//Пример работы главного потока исполнения
Thread t = Thread.currentThread();
System.out.println("Teкyщий поток исполнения: " + t);
t.setName("MyThread");

System.out.println("Пocлe изменения имени потока: " + t);

try {
    for(int n = 5; n > 0; n--){
        System.out.println(n);
        Thread.sleep(1000);
    }
} catch(InterruptedException е){
    System.out.println("Глaвный поток исполнения прерван");
}

По умолчанию главный поток исполнения имеет имя main и приоритет, равный 5.

Методы объекта Thread
static void sleep(long)
final void setName(String)
final String getName()

Способы создание потока исполнения
 - реализовать интерфейс Runnable;
 - расширить класс Thread;

Родительский поток должен завершаться последним во избежания проблем

Определение, что дочерний поток завершен
 - isAlive() - true если поток не завершен
 - join() - ожидание завершения потока

Потоки прекращают исполнение после того, как вызовы метода join() возвращают управление.

Установка приоритета потока
final void setPriority (int уроsенъ)


Способы синхронизации
 - цикличный опрос и ключевое слово synchronized
 - взаимодействие потоков с помощью методов wait, notify, notifyAll (реализованы в Object, поэтому доступны всем классам)


 
Синхронизация
 - 1 поток владеет монитором
 - другие потоки ожидают монитор (приостановлены)

Объявление метода, который можно вызывать только по очереди,
чтобы исключить состояние гонок
synchronized void call (String msg)

Объявление блока кода, который можно выполнять только по очереди,
чтобы исключить состояние гонок
synchronized (target) {
    //синхронизированный блок
    target.call(msg);
}

target - ссылка на синхронизируемый объект



Механизм взаимодействия потоков исполнения с помощью методов.
Все 3 метода могут быть вызваны только из синхронизированного контекста.
1. wait() - вынуждает вызывающий поток исполнения уступить мони­тор 
и перейти в состояние ожидания до тех пор, пока какой-нибудь другой
поток исполнения не войдет в тот же монитор и не вызовет метод notify()
2. notify() - возобновляет исполнение потока, из которого был вызван
метод wait() для того же самого объекта
3. notifyAll() - возобновляет исполнение всех потоков, из которых
был вызван метод wait() для того же самого объекта. Одному из этих 
пото­ков предоставляется доступ.


Взаимная блокировка

Приостановка, возобновление и остановка потоков исполнения

Методы suspend(), resume() и stop() в классе Thread начиная с java 2 НЕ рекоммендуется использовать.

Вместо этого следует, чтобы код исполнения run периодически проверял,
должно ли исполнение потока быть приостановлено, возобновлено или прервано.

Обычно для этого служит флаговая переменная, обозначающая состояние потока исполнения и методы wait() и notify().

Получение состояния потока:
Thread.StategetState() - возвращает значение типа Thread.State, одно из:
 - BLOCКED
 - NEW
 - RUNNAВLE
 - TERМINATED
 - TIМED_WAITING
 - WAITING

Пример:
Thread.State ts = thrd.getState();
if(ts == Thread.State.RUNNABLE){
    //...
}

Важно, что состояние потока исполнения может изме­ниться после вызова метода getState();

Для разработки многопоточных приложений рекоммендуется пользоваться каркасом Fork/Join Framework




