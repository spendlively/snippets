

//////////////////////////////////////////////////////////////////////////
////////////////////////////Основные команды//////////////////////////////
//////////////////////////////////////////////////////////////////////////
//Проверка правильности установки Docker
docker run debian echo "Hello World"

//Запустить командную оболочку shell внутри контейнера
docker run -i -t debian /bin/bash
exit
//-i и -t - необходимо создать сеанс интер­активной работы
//на подключаемом терминальном устройстве tty

//Инициализация нового контейнера
docker run -h CONTAINER -i -t debian /bin/bash
//-h - задать имя хоста
//чтобы задать имя: docker run --name boris debian echo "Boo"

//Больше информации о конкретном контейнере
docker ps
//все контейнеры, включая остановленные
docker ps -a
docker inspect stupefied_turing
//stupefied_turing - NAME из вывода docker ps

//список файлов, измененных в работающем контейнере
docker diff stupefied_turing

//список всех событий, произошедших внутри заданного контейнера
docker logs stupefied_turing

//удалить контейнер
docker rm stupefied_turing
//удалить все остановленные контейнеры
docker rm -v $(docker ps -aq -f status=exited)



//////////////////////////////////////////////////////////////////////////
/////////////////////////Создание нового контейнера///////////////////////
//////////////////////////////////////////////////////////////////////////

//Запуск контейнера и установка пакетов
docker run -it --name cowsay --hostname cowsay debian bash
apt-get update
apt-get install -y cowsay fortune
/usr/games/fortune | /usr/games/cowsay
exit

//Сохранение контейнера
//не имеет значения, работает контейнер или он остановлен
//cowsay - имя
docker commit cowsay test/cowsayimage

//Запустить образ с предустановленным приложением
docker run test/cowsayimage /usr/games/cowsay "Moo"

//Если нужно что-то изменить,
//придется вручную повторить все ранее проделанные операции
//Решение этой проблемы заключается в использовании специального
//файла Dockerfile для создания образа и автоматизированного
//повторного воспроизведения этой процедуры.



//////////////////////////////////////////////////////////////////////////
/////////////////////Создание образов из Dockerfile///////////////////////
//////////////////////////////////////////////////////////////////////////

//Создадим новый каталог
mkdir cowsay
cd cowsay
touch Dockerfile

//Добавим содержимое в Dockerfile
FROM debian:wheezy
RUN apt-get update && apt-get install -y cowsay fortune
//FROM - базовый образ ОС
//FROM - строго обязательная для всех файлов Dockerfile
//самая первая незакомментированная инструкция
//RUN определяет команды, выполняемые в командной оболочке внутри данного образа

//Создание образа (в том же каталоге, где расположен наш Dockerfile)
docker build -t test/cowsay-dockerfile .

//После этого мы можем запускать образ точно таким же способом, как раньше
docker run test/cowsay-dockerfile /usr/games/cowsay "Moo"



//Можно упростить, добавив в Dockerfile ENTRYPOINT
//ENTRYPOINT позвлояет определить выполняемый файл, который будет
//вызываться для обработки любых аргументов, переданных в команду docker run
//Dockerfile:
FROM debian:wheezy
RUN apt-get update && apt-get install -y cowsay fortune
//Запуск
docker build -t test/cowsay-dockerfile .
docker run test/cowsay-dockerfile "Moo"



//Создание скрипта для инструкции ENTRYPOINT
//entrypoint.sh
#!/bin/bash
if [ $# -eq 0 ]; then
        /usr/games/fortune | /usr/games/cowsay
    else
        /usr/games/cowsay "$@"
fi

//Делаем скрипт исполняемым
chmod +x entrypoint.sh

//Dockerfile
FROM debian
RUN apt-get update && apt-get install -y cowsay fortune
COPY entrypoint.sh /
ENTRYPOINT ["/entrtypoint.sh"]
//COPY копирует файл из файловой системы хоста в файловую систему образа
//первый аргумент определяет файл хоста, а второй – целевой путь,
//как в команде cp

//Запуск
docker build -t test/cowsay-dockerfile .
docker run test/cowsay-dockerfile
docker run test/cowsay-dockerfile Hello Moo



//Образы Docker состоят из нескольких уровней (layers).
//Каждый уровень представляет собой защищенную от записи файловую систему.
//Для каждой инструкции в Dockerfile создается свой уровень, который размещается поверх предыдущих уровней.
//Во время преобразования образа в контейнер (командой docker run
//или docker create ) механизм Docker выбирает нужный образ и добавляет на самом
//верхнем уровне файловую систему с возможностью записи
//для файловой системы AUFS установлен строгий лимит, равный 127 уровням
//Dо многих файлах Dockerfile можно обнаружить попытку свести к минимуму количество
//уровней посредством записи нескольких команд Unix в одной инструкции RUN.



//////////////////////////////////////////////////////////////////////////
///////////////////////////Реестры Docker/////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//Docker Hub
http://registry.hub.docker.com

//Реестры, репозитории, образы и теги
1. Реестр (registry) – сервис, отвечающий за хранение и распространение образов.
По умолчанию используется реестр Docker Hub;

2. Репозиторий (repository) – набор взаимосвязанных образов 
(обычно представляющих различные версии одного приложения или сервиса)

3. Тег (tag) – алфавитно-цифровой идентификатор, присваиваемый образам внут­ри репозитория
(например, 14.04 или stable)


//Скачивание из реестра
//Скачивание образа с тегом latest в репозиторий amouat/revealjs из реестра Docker Hub
docker pull amouat/revealjs:latest

//Загрузка в реестр
//1. Регистрируемся на сайте или с помощью команды docker login
//2. Добавляем MAINTAINER в Dockerfile
FROM debian
MAINTAINER John Smith <john@smith.com>
RUN apt-get update && apt-get install -y cowsay fortune
COPY entrypoint.sh /
ENTRYPOINT ["/entrypoint.sh"]
//3. Заново генерируем образ
docker build -t amouat/cowsay .
//4. Выгрузим образ в Docker Hub
docker push amouat/cowsay

//Так как после имени репозитория не указан тег,
//образу был автоматически присвоен тег latest



//////////////////////////////////////////////////////////////////////////
//////////////////////////Официальный образ Redis/////////////////////////
//////////////////////////////////////////////////////////////////////////

//Имена образов
1. user-name/image-name - пользовательские образы
2. redis - официальные образы (пространство имен root)
3. localhost:5000/wordpress - образы в сторонних реестрах

//Загрузка официального образа redis
docker pull redis

//Запуск
docker run --name myredis -d redis
//-d - контейнер нужно запустить в фоновом режиме

//Новый контейнер для для запуска в нем redis-cli
docker run --rm -it --link myredis:redis redis /bin/bash
//--link - установление соединения между контейнерами myredis и redis

//В будущем место установления соединения (link) 
//вероятно будет использоваться публикация сервисов (publish services)

//////////////////////////////////////////////////////////////////////////
//////////////////////////Тома (Volumes)/////////////////////////
//////////////////////////////////////////////////////////////////////////
// - это файлы или каталоги, которые смонтированы непосредственно на хосте
//и не являются частью каскадно-объединенной файловой системы.

//Другие контейнеры могут совместно использовать их

//Способы объявления каталога как тома
//1. Инструкция VOLUME в Dockerfile
VOLUME /data

//2. Включение флага -v в команду docker run
docker run -v /data test/webserver

//По умолчанию заданный каталог или файл будет смонтирован на хосте внутри
//каталога, в котором был установлен Docker (обычно это каталог /var/lib/docker/)

//Чтобы определить другой каталог
docker run -d -v /host/dir:/container/dir test/webserver

//В файле Dockerfile определить каталог хоста как точку монтирования невозможно
//по причинам, связанным с обеспечением переносимости и безопасности


//Пример с redis
//предполагается, что контейнер myredis продолжает работу
docker run --rm -it --link myredis:redis redis /bin/bash
> redis-cli -h redis -p 6379
> set "persistence" "test"
> save
> exit
> exit
docker run --rm --volumes-from myredis -v $(pwd)/backup:/backup debian cp /data/dump.rdb /backup/
ls backup


//Обратите внимание на то, что аргумент -v использован для монтирования 
//известного нам существующего каталога хоста, а аргумент --volumes-from – 
//для установления соединения между новым контейнером и каталогом базы данных Redis

//После завершения работы с контейнером myredis можно остановить и удалить его:
docker stop myredis
docker rm -v myredis

//Все оставшиеся вспомогательные контейнеры можно удалить с помощью коман­ды
docker rm $(docker ps -aq)

























