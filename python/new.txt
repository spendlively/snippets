//Сравнение в строку
10 < 11 < 12


//Общепринятый codestyle
snake_case


//Форматирование строки с помощью %
arr = [1, 2, 3]
'Like printf %s' % arr

'%s %%s' % 12


//Форматирование строки с помощью format()
"{1} {0} {1}'.format(1, 2)

'{:.2f}'.format(1.2345)
'%.2f' % 1.2345


//Форматирование строки с помощью f''
value = 123
f'text: {value!r}'


//Вложенные функции
//Область видимости как в js
def one(x):
    def two(y):
        return x * y
    return two

one(2)(3) # 6


//reduce
from functools import reduce

rng = range(1, 7)
value = reduce(lambda x, y: x * y, rng)
value = reduce(lambda x, y: x * y, rng, 10)


//Декораторы
//Декоратор - функция, в которую будет передана полозовательская функция

//Пример без декоратора
def decorator(foo):
    def wrapper():
        print('Decorator text')
        foo()
    return wrapper

def bar():
    print('Function text')

bar = decorator(bar)
bar()


//Пример с декоратором
def decorator_foo(foo):
    def wrapper():
        print('Decorator text')
        foo()
    return wrapper

@decorator_foo
def another():
    print('Function text')

another()


//Декоратор с параметрами
def decorator(foo):
    def wrapper(*args, **kwargs):
        print(args, kwargs)
        return foo(*args, **kwargs)
    return wrapper

@decorator
def bar(a, b):
    return a + b

print(bar(1, 2))
print('===================')
print(bar(a=1, b=2))


//Функция возвращаюащая декоратор
def gen_dec(x):
    def decorator(foo):
    ...
    return decorator

@gen_dec(42)
def foo():
    pass


# Хороший тон - использовать functools.wraps над враппером,
# wraps передает декорируемой функции значения,
# кот. были в исходной функции
# C wraps: итоговая sum = <function __main__.sum(a,b)>
# Без wraps: итоговая sum = <function __main__.gen_dec.<locals>.decorator.<locals>.wrapper()>
from functools import wraps

def gen_dec(x):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return x + func(*args, **kwargs)
        return wrapper
    return decorator

@gen_dec(10)
def sum(a, b):
    return a + b

print(sum(1, 2))  # 13


# With .. as
# With .. as гарантирует, что если призойдет ошибка, критические функции 100% сработают.
# Используется для оборачивания выполнения блока инструкций менеджером контекста.
# В примере файл будет закрыт, если во время выполнения произойдет ошибка.
# Если with..as что-то открыывает, он это гарантированно закрывает.

with open("test.txt", "a") as f:
    # если тут произойдет ошибка, файл все равно закроется
    f.write("Строка\n")


# Еще пример использования контекстного менеджера
from contextlib import contextmanager

@contextmanager
def managed_res(*args):
    print(args)
    yield map(lambda x: x * 2, args)
    print('Closed', args)

with managed_res(1, 2, 3) as g:
    print(list(g))
    print("Leaving")

print('Left')

# (1, 2, 3)
# [2, 4, 6]
# Leaving
# Closed (1, 2, 3)
# Left
