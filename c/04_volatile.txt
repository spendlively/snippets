
//volatile
 - информирует компилятор о том, что переменная может быть изменена
не только из текущего выполняемого кода, но и из других мест
 - компилятор будет избегать определенных оптимизаций этой переменной



//Примеры volatile переменных:
//1. Регистры в периферийных устройствах (например, регистры состояния)
//2. Глобальные переменные, используемые в обработчиках прерываний.
//3. Глобальные переменные, используемые совместно несколькими задачами
в многопотоковом приложении.



//Вопросы
//1. Может ли аргумент быть одновременно и const и volatile?
 - Да
 - Например, регистр состояния доступный только для чтения.
 - Он volatile, потому что может меняться неожиданно.
 - Он const, потому что программа не должна пытаться изменить его.

//2. Может ли указатель быть volatile?
 - Да.
 - Хотя это не общепринятый случай.
 - Например, когда обработчик прерываний изменяет указатель на буфер.

//3. Что не так со следующей функцией?
int square(volatile int *ptr)
{
   return *ptr * *ptr;
}
 - Эта функция потенциально опасна.
 - Назначение кода состоит в возвращении квадрата значения, указанного при помощи *ptr.
 - Однако, поскольку *ptr указывает на volatile переменную, компилятор сгенерирует код,
который выглядит примерно так:
int square(volatile int *ptr)
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}

 - Поскольку значение переменной на которую указывает ptr может неожиданно измениться,
то существует возможность, что «а» и «b» будут разными.
 - Следовательно, этот код может возвратить число, которое не будет квадратом!
 - Правильный вариант кода в данном случае такой:
int square(volatile int *ptr)
{
   int a;
   a = *ptr;
   return a * a;
}
